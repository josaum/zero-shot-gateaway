# LLMs.txt - One-File Event Gateway (TUI Edition)

## Project Overview
A single-binary Rust application serving as a high-performance Event Gateway with a Terminal User Interface (TUI).
- **Core**: Rust + Axum + Tokio
- **Database**: DuckDB with Arrow integration
- **UI**: Ratatui (Terminal UI)
- **AI**: Gemini API for chat and intent detection

## File Structure
```
/
├── src/main.rs          # BACKEND: API routes, DB setup, State, AI Logic
├── src/tui.rs           # FRONTEND: Ratatui rendering, Input handling, Arrow processing
├── Cargo.toml           # Dependencies (duckdb + vtab-arrow)
├── README.md            # Documentation
└── .env                 # API Keys
```

## System Constraints (CRITICAL)
1.  **TUI Performance**: The render loop must remain non-blocking. Heavy tasks go to `tokio::spawn`.
2.  **Zero-Copy Arrow**: Data retrieval for the UI uses `duckdb::Arrow` to fetch `RecordBatch`es directly. Avoid deserializing into `Vec<Struct>` for high-volume event lists.
3.  **Real-time Signaling**: UI updates are triggered by `tokio::sync::broadcast`, NOT polling.

## Dependencies context
```toml
axum = "0.7"
tokio = { version = "1", features = ["full"] }
duckdb = { version = "1.0", features = ["bundled", "vtab-arrow"] }
ratatui = "0.29"
crossterm = "0.28"
reqwest = "0.12"
```

## Key Patterns

### TUI Data Flow
1. API receives Event.
2. API saves to DuckDB.
3. API sends signal on `tx_notify` broadcast channel.
4. TUI background task wakes up, queries DuckDB (Arrow), sends `RecordBatch` to UI thread.
5. UI thread redraws frame using Arrow columns directly.

### AI Chat Flow
1. User types in TUI (Edit Mode).
2. TUI POSTs to local `/api/chat`.
3. Handler builds context from `AppState.schemas`.
4. Handler calls Gemini API -> Returns Intent/Slots.
5. Response displayed in Chat UI.
